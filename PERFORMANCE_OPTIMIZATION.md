Global history recording – recordTileHistory walks every tile each frame and pushes/maintains 10 s of samples even though only the inspected tile needs a history (game.html:633-641). That’s 1024 pushes and occasional shift() calls per frame in this 32×32 world, which quickly becomes the dominant CPU+GC cost as you increase the grid or frame rate. Consider tracking history only for tiles that are being observed (or sampling lazily when the inspector requests it).

Inspector rebuild on every frame – even though renderInspectorAt checks against lastInspectorMarkup, it still composes the full markup string each loop (game.html:764-771). Each composition performs several Object.entries, filters, sorts, and string concatenations (game.html:686-758). Doing this every RAF tick results in heavy allocation and GC churn. You can memoize per-section data, short‑circuit when nothing meaningful changed, or throttle updates to when the tile state actually mutates.

Per-frame sorting of species lists – renderBarSection always sorts and maps the entire species/gas/solid payloads, even when quantities are unchanged (game.html:686-695). For tiles with many species this becomes O(n log n) work each frame. Cache sorted order or only recompute when the set/values change beyond a threshold.

Repeated diffusions allocate fresh grids – each diffusion pass allocates a brand-new deltas array-of-arrays (game.html:582-588). Because simulateFrame calls diffuse multiple times per substep (and substeps per frame), this hot path repeatedly hits the allocator. Reusing a scratch buffer or switching to in-place diffusion where possible would trim both CPU and GC pressure.
